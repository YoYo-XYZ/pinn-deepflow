{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DeepFlow: Physics-Informed Neural Networks for Fluid Dynamics","text":"<p>DeepFlow is a user-friendly framework for solving PDEs, with a focus on fluid dynamics including the Navier\u2013Stokes equations, using Physics-Informed Neural Networks (PINNs). It provides a CFD-solver-style workflow that makes PINN-based simulations accessible and straightforward.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Key Features</li> <li>Current Implementations</li> <li>Installation</li> <li>Requirements</li> <li>Quick Start</li> <li>Examples</li> <li>Contributing</li> <li>License</li> <li>DeepFlow Milestones</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u27c1 Physics-Attached Geometry: AUTO GENERATE TRAINING DATA by explicitly attach physics and neural network to geometries.</li> <li>\ud83d\udd27 CFD-Solver Style: Straightforward workflow similar to CFD software.</li> <li>\ud83d\udcca Built-in Visualization: Tools to evaluate and plot results.</li> <li>\ud83d\ude80 GPU Acceleration: Enable GPU for faster training.</li> <li>Flexible Domain Definition: Easily define complex 2D geometries.</li> </ul>"},{"location":"#current-implementations","title":"Current Implementations","text":"<ul> <li>Supported problems: solving forward partial differential equations (PDEs)<ul> <li>transient &amp; steady 2D imcompressible Navier-Stokes equations, 2D Fourier Heat equation, Burgers' equation</li> </ul> </li> <li>Sampling methods: Uniform, Random, Latin Hypercube Sampling, RAR-G [0], R3 [1]</li> <li>2D Geometries: Custom functions, Rectangle, Circle, Polygon, and combinations &amp; subtractions.</li> <li>Hard Boundary Conditions: Automatic Hard BC w.r.t. to geometry.</li> <li>Neural Network Architectures: Fully connected feedforward networks (FNN).</li> <li>Optimizers: Adam, L-BFGS</li> <li>Backend: PyTorch</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install DeepFlow via pip:</p> <pre><code>pip install deepflow\n</code></pre> <p>For development or to build from source:</p> <pre><code>git clone https://github.com/YoYo-XYZ/deepflow.git\ncd deepflow\npip install -e .\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.8</li> <li>PyTorch &gt;= 1.7.0</li> <li>NumPy &gt;= 1.19.0</li> <li>Matplotlib &gt;= 3.3.0</li> <li>SymPy &gt;= 1.5.0</li> <li>SciPy &gt;= 1.5.0</li> <li>Ultrplot &gt;= 1.0.0</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p> This example demonstrates how to simulate Steady channel flow under 20 lines of code! We recommend using a Python notebook (<code>.ipynb</code>) for interactive experience.</p>"},{"location":"#1-define-the-geometry-and-physics","title":"1. Define the Geometry and Physics","text":"<p><pre><code>import deepflow as df\n\n# Define the area and bounds\nrectangle = df.geometry.rectangle([0, 5], [0, 1])\ndomain = df.domain(rectangle)\n\ndomain.show_setup() # Display the domain setup\n</code></pre> <pre><code># Define Boundary Conditions\ndomain.bound_list[0].define_bc({'u': 1, 'v': 0})  # Inflow: u=1\ndomain.bound_list[1].define_bc({'u': 0, 'v': 0})  # Wall: No slip\ndomain.bound_list[2].define_bc({'p': 0})          # Outflow: p=0\ndomain.bound_list[3].define_bc({'u': 0, 'v': 0})  # Wall: No slip\n\n# Define PDE (Navier-Stokes)\ndomain.area_list[0].define_pde(df.pde.NavierStokes(U=0.0001, L=1, mu=0.001, rho=1000))\n\ndomain.show_setup() # Display the domain setup\n</code></pre> </p> <p><pre><code># Sample points: [Left, Bottom, Right, Top], [Interior]\ndomain.sampling_random([200, 400, 200, 400], [5000])\ndomain.show_coordinates(display_physics=True)\n</code></pre> </p>"},{"location":"#2-create-and-train-the-model","title":"2. Create and Train the model","text":"<p><pre><code># Initialize the PINN model\nmodel0 = df.PINN(width=40, length=4)\n</code></pre> <pre><code># Train the model using Adam Optimizer\nmodel1 = model0.train_adam(\n    calc_loss=df.calc_loss_simple(domain),\n    learning_rate=0.001,\n    epochs=2000,)\n</code></pre></p>"},{"location":"#3-visualize-results","title":"3. Visualize Results","text":"<p><pre><code># Evaluate the best model\nprediction = domain.area_list[0].evaluate(model1_best)\nprediction.sampling_area([500, 100])\n\n# Plot Velocity Field\n_ = prediction.plot_color('u', cmap='jet')\n\n# Plot Training Loss\n_ =prediction.plot_loss_curve()\n</code></pre> </p>"},{"location":"#examples","title":"Examples","text":"<p>Explore the examples  directory for real use cases, including</p> <p>Steady-state: - Steady flow around a cylinder - Lid-driven cavity flow - Backward-facing step flow - Burgers' Equation</p> <p>Time-dependent: - Transient channel flow - Fourier Heat Equation</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Feel free to submit a Pull Request. For major changes, open an issue first to discuss the proposed changes.</p>"},{"location":"#deepflow-milestones","title":"DeepFlow Milestones","text":"<ol> <li>Define custom PDE</li> <li>Inverse problems PDE</li> <li>3D Geometries</li> <li>More sampling methods</li> <li>More neural network architectures (e.g., CNN, RNN)</li> </ol>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"BFS_flow_steady/","title":"Steady BFS Flow","text":"<p>Backward Facing Step Flow (BFS) DEMO code</p> <p>This notebook demonstrates solving steady-state Backward Facing Step Flow (BFS) using DeepFlow. The BFS flow is a common benchmark problem in fluid dynamics, where the flow separates and reattaches after encountering a step.</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n</code></pre> <pre><code>Deepflow is runned on: cuda\n</code></pre>"},{"location":"BFS_flow_steady/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain: a rectangle with a circular obstacle (cylinder). This defines the area for simulation.</p> <pre><code>rectangle = df.geometry.rectangle(0, 5)\n</code></pre> <pre><code>domain = df.domain(rectangle)\ndomain.show_setup()\n</code></pre> <p></p>"},{"location":"BFS_flow_steady/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Navier-Stokes equations for fluid flow and apply boundary conditions (e.g., no-slip walls, inlet velocity).</p> <pre><code>domain.bound_list[0].define_bc({'u': 0,'v': 0})\ndomain.bound_list[1].define_bc({'u': df.parabolic_func('y', 0.6, 1, 0.7),'v': 0})\ndomain.bound_list[2].define_bc({'u': 0,'v': 0})\ndomain.bound_list[3].define_bc({'p': 0})\ndomain.bound_list[4].define_bc({'u': 0,'v': 0})\ndomain.bound_list[5].define_bc({'u': 0,'v': 0})\ndomain.area_list[0].define_pde(df.NavierStokes(U=0.0001, L=1, mu=0.001, rho=1000))\ndomain.show_setup()\n</code></pre> <p></p> <p>Sample initial points for training.</p> <pre><code>domain.sampling_lhs(bound_sampling_res=[1000, 1000, 1000, 1000, 1000, 1000], area_sampling_res=[2000])\ndomain.show_coordinates(display_physics=False)\n</code></pre> <p></p>"},{"location":"BFS_flow_steady/#3-train-the-pinn-model","title":"3. Train the PINN model","text":"<p>Define how collocation points are sampled during training.</p> <pre><code>def do_in_adam(epoch, model):\n    return\n\ndef do_in_lbfgs(epoch, model):\n    return\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3(bound_sampling_res=[1000, 1000, 1000, 1000, 1], area_sampling_res=[2000])\n        print(domain)\n</code></pre> <p>Train the model using Adam for initial training (faster convergence).</p> <pre><code>model0 = df.PINN(width=50, length=5, input_vars=['x','y'], output_vars=['u','v','p'])\n\n# Train the model\nmodel1, model1best = model0.train_adam(\n    learning_rate=0.001,\n    epochs=2000,\n    calc_loss=df.calc_loss_simple(domain),\n    threshold_loss=0.005,\n    do_between_epochs=do_in_adam)\n</code></pre> <pre><code>Epoch: 1, total_loss: 54.85159, bc_loss: 54.85147, pde_loss: 0.00012\nEpoch: 200, total_loss: 16.55980, bc_loss: 14.83081, pde_loss: 1.72898\nEpoch: 400, total_loss: 6.10844, bc_loss: 3.86418, pde_loss: 2.24426\nEpoch: 600, total_loss: 2.69913, bc_loss: 1.27305, pde_loss: 1.42608\nEpoch: 800, total_loss: 1.61956, bc_loss: 0.74461, pde_loss: 0.87495\nEpoch: 1000, total_loss: 1.06095, bc_loss: 0.57254, pde_loss: 0.48841\nEpoch: 1200, total_loss: 0.82440, bc_loss: 0.47019, pde_loss: 0.35421\nEpoch: 1400, total_loss: 0.70941, bc_loss: 0.40436, pde_loss: 0.30506\nEpoch: 1600, total_loss: 0.63107, bc_loss: 0.36355, pde_loss: 0.26752\nEpoch: 1800, total_loss: 0.57608, bc_loss: 0.33324, pde_loss: 0.24283\nEpoch: 2000, total_loss: 0.52760, bc_loss: 0.30945, pde_loss: 0.21815\n</code></pre> <p>Refine the model using LBFGS for higher precision.</p> <pre><code># Train the model\nmodel2 = model1best.train_lbfgs(\n    calc_loss=df.calc_loss_simple(domain),\n    epochs=350,\n    threshold_loss=0.0001,\n    do_between_epochs=do_in_lbfgs)\n</code></pre> <pre><code>Epoch: 2001, total_loss: 0.51926, bc_loss: 0.30645, pde_loss: 0.21282\nEpoch: 2051, total_loss: 0.11804, bc_loss: 0.07386, pde_loss: 0.04419\nEpoch: 2101, total_loss: 0.02810, bc_loss: 0.01461, pde_loss: 0.01349\nEpoch: 2151, total_loss: 0.01070, bc_loss: 0.00528, pde_loss: 0.00542\nEpoch: 2201, total_loss: 0.00528, bc_loss: 0.00256, pde_loss: 0.00272\nEpoch: 2251, total_loss: 0.00346, bc_loss: 0.00166, pde_loss: 0.00180\nEpoch: 2301, total_loss: 0.00254, bc_loss: 0.00122, pde_loss: 0.00132\n</code></pre> <pre><code>domain.show_coordinates()\n</code></pre> <p></p> <p>Save or Load the model for later use</p> <pre><code>model2.save_as_pickle(\"model.pkl\")\nmodel2 = df.load_from_pickle(\"model.pkl\")\n</code></pre>"},{"location":"BFS_flow_steady/#4-post-evaulation","title":"4. Post Evaulation","text":""},{"location":"BFS_flow_steady/#41-visualize-area","title":"4.1 Visualize area","text":"<pre><code>df.Visualizer.refwidth_default = 7\n</code></pre> <pre><code># Create object for evaluation\narea_eval = domain.area_list[0].evaluate(model2)\n# Sampling uniform points\narea_eval.sampling_area([300, 60])\n# Show available data's key\nprint(area_eval)\n</code></pre> <pre><code>Available data keys: ('u', 'v', 'p', 'pde_residual', 'x', 'y', 'u_x', 'u_y', 'v_x', 'v_y', 'p_x', 'p_y', 'continuity_residual', 'x_momentum_residual', 'y_momentum_residual', 'total_loss', 'bc_loss', 'pde_loss')\n</code></pre> <pre><code>area_eval['v_mag'] = (area_eval['u']**2 + area_eval['v']**2)**0.5\n</code></pre> <pre><code>_ = area_eval.plot_color('v_mag', s=2, cmap='jet').savefig(\"colorplot_v_mag.png\")\n_ = area_eval.plot_color('u', s=2, cmap='rainbow')\n_ = area_eval.plot_color('v', s=2, cmap='rainbow')\n_ = area_eval.plot_color('p', s=2, cmap='rainbow')\n_ = area_eval.plot_streamline('u', 'v', cmap = 'jet')\n_ = area_eval.plot_color('pde_residual', s=2, cmap='viridis')\n</code></pre>"},{"location":"BFS_flow_steady/#42-visualize-neural-network-data","title":"4.2 Visualize Neural Network data","text":"<pre><code>_ = area_eval.plot_loss_curve(log_scale=True)\n</code></pre>"},{"location":"BFS_flow_steady/#44-export-data","title":"4.4 Export data","text":"<pre><code># store the x,y,velocity_magnitude data\nx_data = area_eval.data_dict['x']\ny_data = area_eval.data_dict['y']\nu_data = area_eval.data_dict['u']\n\n#save as txt file\nimport numpy as np\narray = np.column_stack((x_data, y_data, u_data))\nnp.savetxt('outlet_velocity.txt', array)\n</code></pre>"},{"location":"burgers_eq/","title":"1D Burgers Equation DEMO code","text":"<p>This notebook demonstrates solving 1D Burgers Equation (spatial xy version) using PINNs.</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n</code></pre> <pre><code>Deepflow is runned on: cuda\n</code></pre>"},{"location":"burgers_eq/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain</p> <pre><code>area = df.geometry.rectangle([-1, 1], [0, 1])\nline_ic = df.geometry.line_horizontal(y=0, range_x=[-1,1])\nline_bc1 = df.geometry.line_vertical(x=-1, range_y=[0,1])\nline_bc2 = df.geometry.line_vertical(x=1, range_y=[0,1])\ndomain = df.domain(area.area_list, line_ic, line_bc1, line_bc2)\ndomain.show_setup()\n</code></pre> <p></p>"},{"location":"burgers_eq/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Burgers eq (spatial version) apply boundary conditions.</p> <pre><code># Define PDE\nfrom torch import sin, pi\ndomain.area_list[0].define_pde(df.pde.BurgersEquation1D(nu=0.01/pi))\ndomain.bound_list[0].define_bc({'u':['x', lambda x: -sin(pi * x)]})\ndomain.bound_list[1].define_bc({'u': 0})\ndomain.bound_list[2].define_bc({'u': 0})\n</code></pre>"},{"location":"burgers_eq/#2-generate-training-data","title":"2. Generate Training Data","text":"<p>Sample initial points for training. After sampling, Deepflow will automatically generate training datasets based on the defined physics.</p> <pre><code># Sample points: [Left, Bottom, Right, Top], [Interior]\ndomain.sampling_lhs([2000, 1000, 1000], [4000])\ndomain.show_coordinates(display_physics=True)\n</code></pre> <p></p>"},{"location":"burgers_eq/#3-train-the-model","title":"3. Train the Model","text":"<p>Define the resampling scheme during training. R3 scheme is recommended.</p> <pre><code>def do_in_adam(epoch, model):\n    if epoch % 500 == 0 and epoch &gt; 0:\n        domain.sampling_R3([2000, 1000, 1000], [4000])\n        print(domain)\n\ndef do_in_lbfgs(epoch, model):\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3([2000, 1000, 1000], [4000])\n        print(domain)\n</code></pre> <p>Train the model using Adam optimizer followed by L-BFGS optimizer.</p> <pre><code>model0 = df.PINN(input_vars=['x', 'y'], output_vars=['u'], width=16, length=4)\n\nmodel1, model1_best = model0.train_adam(\n    calc_loss = df.calc_loss_simple(domain),\n    learning_rate=0.015,\n    epochs=4000,\n    do_between_epochs=do_in_adam)\n</code></pre> <pre><code>Epoch: 1, total_loss: 0.63708, bc_loss: 0.63691, pde_loss: 0.00018\nEpoch: 200, total_loss: 0.10178, bc_loss: 0.05901, pde_loss: 0.04277\nEpoch: 400, total_loss: 0.07294, bc_loss: 0.04452, pde_loss: 0.02842\nnumber of bound : ['0: 3065', '1: 1693', '2: 1482']\nnumber of area : ['0: 5407']\nEpoch: 600, total_loss: 0.10885, bc_loss: 0.07805, pde_loss: 0.03080\nEpoch: 800, total_loss: 0.01511, bc_loss: 0.00641, pde_loss: 0.00870\nEpoch: 1000, total_loss: 0.01650, bc_loss: 0.00472, pde_loss: 0.01178\nnumber of bound : ['0: 3800', '1: 2198', '2: 1813']\nnumber of area : ['0: 6625']\nEpoch: 1200, total_loss: 0.01325, bc_loss: 0.00356, pde_loss: 0.00969\nEpoch: 1400, total_loss: 0.00802, bc_loss: 0.00367, pde_loss: 0.00435\nnumber of bound : ['0: 4617', '1: 2747', '2: 2254']\nnumber of area : ['0: 7925']\nEpoch: 1600, total_loss: 0.00648, bc_loss: 0.00290, pde_loss: 0.00358\nEpoch: 1800, total_loss: 0.00302, bc_loss: 0.00102, pde_loss: 0.00201\nEpoch: 2000, total_loss: 0.00735, bc_loss: 0.00360, pde_loss: 0.00375\nnumber of bound : ['0: 5493', '1: 3284', '2: 2527']\nnumber of area : ['0: 8984']\nEpoch: 2200, total_loss: 0.00176, bc_loss: 0.00045, pde_loss: 0.00131\nEpoch: 2400, total_loss: 0.00930, bc_loss: 0.00278, pde_loss: 0.00652\nnumber of bound : ['0: 6255', '1: 3747', '2: 2913']\nnumber of area : ['0: 9964']\nEpoch: 2600, total_loss: 0.02079, bc_loss: 0.00154, pde_loss: 0.01925\nEpoch: 2800, total_loss: 0.00742, bc_loss: 0.00078, pde_loss: 0.00664\nEpoch: 3000, total_loss: 0.00273, bc_loss: 0.00114, pde_loss: 0.00159\nnumber of bound : ['0: 6923', '1: 4220', '2: 3455']\nnumber of area : ['0: 10893']\nEpoch: 3200, total_loss: 0.00098, bc_loss: 0.00024, pde_loss: 0.00074\nEpoch: 3400, total_loss: 0.00073, bc_loss: 0.00017, pde_loss: 0.00056\nnumber of bound : ['0: 7651', '1: 4733', '2: 3835']\nnumber of area : ['0: 11927']\nEpoch: 3600, total_loss: 0.01580, bc_loss: 0.00201, pde_loss: 0.01380\nEpoch: 3800, total_loss: 0.00503, bc_loss: 0.00171, pde_loss: 0.00332\nEpoch: 4000, total_loss: 0.04200, bc_loss: 0.01015, pde_loss: 0.03185\nnumber of bound : ['0: 8525', '1: 5214', '2: 4219']\nnumber of area : ['0: 12743']\n</code></pre> <pre><code>model2 = model1_best.train_lbfgs(calc_loss = df.calc_loss_simple(domain), epochs=500, do_between_epochs=do_in_lbfgs)\n</code></pre> <pre><code>Epoch: 3945, total_loss: 0.00049, bc_loss: 0.00009, pde_loss: 0.00041\nEpoch: 3995, total_loss: 0.00002, bc_loss: 0.00000, pde_loss: 0.00002\nTraining interrupted by user.\n</code></pre> <pre><code>domain.show_coordinates(display_physics=False)\n</code></pre> <p></p>"},{"location":"burgers_eq/#4-visualization","title":"4. Visualization","text":"<pre><code># Evaluate the best model\nprediction = domain.area_list[0].evaluate(model2)\n# Sampling uniform points\nprediction.sampling_area([500, 250])\n</code></pre>"},{"location":"burgers_eq/#41-visualize-pde-area","title":"4.1 Visualize PDE area","text":"<pre><code># Plot Velocity Field\nprediction.plot_color('u', cmap = 'jet', s=0.3).savefig('u_field.png')\n_ = prediction.plot_color('pde_residual', cmap = 'rainbow', s=0.3)\n_ = prediction.plot('pde_residual')\n_ = prediction.plot_loss_curve(log_scale=True)\n</code></pre> <pre><code>C:\\Users\\thamm\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\IPython\\core\\events.py:82: UltraPlotWarning: Tick label sharing not implemented for &lt;class 'ultraplot.axes.three.ThreeAxes'&gt; subplots.\n  func(*args, **kwargs)\n</code></pre> <pre><code>C:\\Users\\thamm\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\IPython\\core\\pylabtools.py:170: UltraPlotWarning: Tick label sharing not implemented for &lt;class 'ultraplot.axes.three.ThreeAxes'&gt; subplots.\n  fig.canvas.print_figure(bytes_io, **kw)\n</code></pre>"},{"location":"burgers_eq/#42-visualize-u-at-y-075","title":"4.2 Visualize u at y = 0.75","text":"<pre><code>line = df.geometry.line_horizontal(y=0.75, range_x=[-1, 1])\nprediction = line.evaluate(model2)\nprediction.sampling_line(500)\n_ = prediction.plot(y_axis = 'u')\n</code></pre>"},{"location":"cavity_flow_steady/","title":"Steady Cavity Flow","text":"<p>Cylinder Flow (Steady) DEMO code</p> <p>This notebook demonstrates solving steady-state Cavity Flow with the same setup as https://www.comsol.com/blogs/how-to-solve-a-classic-cfd-benchmark-the-lid-driven-cavity-problem.</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n</code></pre> <pre><code>Deepflow is runned on: cuda\n</code></pre>"},{"location":"cavity_flow_steady/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain: a rectangle with a circular obstacle (cylinder). This defines the area for simulation.</p> <pre><code>rectangle = df.geometry.rectangle([0, 1], [0, 1])\npoint = df.geometry.point(0,0)\n</code></pre> <pre><code>domain = df.domain(rectangle, point)\ndomain.show_setup()\n</code></pre> <p></p>"},{"location":"cavity_flow_steady/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Navier-Stokes equations for fluid flow and apply boundary conditions (e.g., no-slip walls, inlet velocity).</p> <pre><code>domain.bound_list[0].define_bc({'u': 0,'v': 0})\ndomain.bound_list[1].define_bc({'u': 0,'v': 0})\ndomain.bound_list[2].define_bc({'u': 0,'v': 0})\ndomain.bound_list[3].define_bc({'u': 1, 'v': 0})\ndomain.bound_list[4].define_bc({'p': 0})\ndomain.area_list[0].define_pde(df.NavierStokes(U=0.0001, L=1, mu=0.001, rho=1000))\ndomain.show_setup()\n</code></pre> <p></p> <p>Sample initial points for training.</p> <pre><code>domain.sampling_lhs(bound_sampling_res=[1000, 1000, 1000, 1000, 10], area_sampling_res=[2000])\ndomain.show_coordinates(display_physics=False)\n</code></pre> <p></p>"},{"location":"cavity_flow_steady/#3-train-the-pinn-model","title":"3. Train the PINN model","text":"<p>Define how collocation points are sampled during training.</p> <pre><code>def do_in_adam(epoch, model):\n    return\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3(bound_sampling_res=[1000, 1000, 1000, 1000], area_sampling_res=[2000])\n        print(domain)\n\ndef do_in_lbfgs(epoch, model):\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3(bound_sampling_res=[1000, 1000, 1000, 1000], area_sampling_res=[2000])\n        print(domain)\n</code></pre> <p>Train the model using Adam for initial training (faster convergence).</p> <pre><code>model0 = df.PINN(width=50, length=5, input_vars=['x','y'], output_vars=['u','v','p'])\n\n# Train the model\nmodel1, model1best = model0.train_adam(\n    learning_rate=0.004,\n    epochs=2000,\n    calc_loss=df.calc_loss_simple(domain),\n    threshold_loss=0.005,\n    do_between_epochs=do_in_adam)\n</code></pre> <pre><code>Epoch: 1, total_loss: 1.25131, bc_loss: 1.25079, pde_loss: 0.00053\nEpoch: 200, total_loss: 0.07023, bc_loss: 0.06000, pde_loss: 0.01023\nEpoch: 400, total_loss: 0.06334, bc_loss: 0.05648, pde_loss: 0.00687\nEpoch: 600, total_loss: 0.05313, bc_loss: 0.04597, pde_loss: 0.00716\nEpoch: 800, total_loss: 0.05231, bc_loss: 0.04092, pde_loss: 0.01139\nEpoch: 1000, total_loss: 0.04184, bc_loss: 0.03366, pde_loss: 0.00818\nEpoch: 1200, total_loss: 0.03640, bc_loss: 0.02686, pde_loss: 0.00954\nEpoch: 1400, total_loss: 0.02922, bc_loss: 0.02091, pde_loss: 0.00831\nEpoch: 1600, total_loss: 0.02525, bc_loss: 0.01836, pde_loss: 0.00689\nEpoch: 1800, total_loss: 0.07843, bc_loss: 0.05686, pde_loss: 0.02157\nEpoch: 2000, total_loss: 0.02943, bc_loss: 0.02339, pde_loss: 0.00604\n</code></pre> <p>Refine the model using LBFGS for higher precision.</p> <pre><code># Train the model\nmodel2 = model1best.train_lbfgs(\n    calc_loss=df.calc_loss_simple(domain),\n    epochs=350,\n    threshold_loss=0.0001,\n    do_between_epochs=do_in_lbfgs)\n</code></pre> <pre><code>Epoch: 1878, total_loss: 0.01468, bc_loss: 0.01227, pde_loss: 0.00241\nEpoch: 1928, total_loss: 0.00323, bc_loss: 0.00235, pde_loss: 0.00088\nEpoch: 1978, total_loss: 0.00238, bc_loss: 0.00167, pde_loss: 0.00071\nnumber of bound : ['0: 1343', '1: 1472', '2: 1194', '3: 1184', '4: 10']\nnumber of area : ['0: 2714']\nEpoch: 2028, total_loss: 0.00342, bc_loss: 0.00230, pde_loss: 0.00112\nEpoch: 2078, total_loss: 0.00237, bc_loss: 0.00178, pde_loss: 0.00059\nnumber of bound : ['0: 1634', '1: 2014', '2: 1499', '3: 1399', '4: 10']\nnumber of area : ['0: 3414']\nEpoch: 2128, total_loss: 0.00085, bc_loss: 0.00057, pde_loss: 0.00028\nEpoch: 2178, total_loss: 0.00030, bc_loss: 0.00015, pde_loss: 0.00014\nnumber of bound : ['0: 1968', '1: 2552', '2: 1707', '3: 1788', '4: 10']\nnumber of area : ['0: 4179']\n</code></pre> <pre><code>domain.show_coordinates()\n</code></pre> <p></p> <p>Save or Load the model for later use</p> <pre><code>model2.save_as_pickle(\"model.pkl\")\nmodel2 = df.load_from_pickle(\"model.pkl\")\n</code></pre>"},{"location":"cavity_flow_steady/#4-visualization","title":"4. Visualization","text":""},{"location":"cavity_flow_steady/#41-visualize-area","title":"4.1 Visualize area","text":"<pre><code>df.Visualizer.refwidth_default = 4\n</code></pre> <pre><code># Create object for evaluation\narea_eval = domain.area_list[0].evaluate(model2)\n# Sampling uniform points\narea_eval.sampling_area([200, 200])\n# Show available data's key\nprint(area_eval)\n</code></pre> <pre><code>Available data keys: ('u', 'v', 'p', 'pde_residual', 'x', 'y', 'u_x', 'u_y', 'v_x', 'v_y', 'p_x', 'p_y', 'continuity_residual', 'x_momentum_residual', 'y_momentum_residual', 'total_loss', 'bc_loss', 'pde_loss')\n</code></pre> <pre><code>area_eval['v_mag'] = (area_eval['u']**2 + area_eval['v']**2)**0.5\n</code></pre> <pre><code>_ = area_eval.plot_color('v_mag', s=1.5, cmap='jet').savefig(\"colorplot_v_mag.png\")\n_ = area_eval.plot_color('u', s=1.5, cmap='rainbow')\n_ = area_eval.plot_color('v', s=1.5, cmap='rainbow')\n_ = area_eval.plot_color('p', s=1.5, cmap='rainbow')\n_ = area_eval.plot_streamline('u', 'v', cmap = 'jet')\n</code></pre>"},{"location":"cavity_flow_steady/#42-visualize-neural-network-data","title":"4.2 Visualize Neural Network data","text":"<pre><code>_ = area_eval.plot_loss_curve(log_scale=True)\n</code></pre>"},{"location":"cavity_flow_steady/#44-export-data","title":"4.4 Export data","text":"<pre><code># store the x,y,velocity_magnitude data\nx_data = area_eval.data_dict['x']\ny_data = area_eval.data_dict['y']\nu_data = area_eval.data_dict['u']\n\n#save as txt file\nimport numpy as np\narray = np.column_stack((x_data, y_data, u_data))\nnp.savetxt('outlet_velocity.txt', array)\n</code></pre>"},{"location":"channel_flow_transient/","title":"Transient Channel Flow","text":"<p>Backward Facing Step Flow (BFS) DEMO code</p> <p>This notebook demonstrates solving steady-state Backward Facing Step Flow (BFS) using DeepFlow. The BFS flow is a common benchmark problem in fluid dynamics, where the flow separates and reattaches after encountering a step.</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n</code></pre> <pre><code>Deepflow is runned on: cuda\n</code></pre>"},{"location":"channel_flow_transient/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain: a rectangle with a circular obstacle (cylinder). This defines the area for simulation.</p> <pre><code>rectangle_pde = df.geometry.rectangle([0,5], [0,1])\nrectange_ic = df.geometry.rectangle([0,5], [0,1])\n</code></pre> <pre><code>domain = df.domain(rectangle_pde, rectange_ic.area_list)\ndomain.show_setup()\n</code></pre> <p></p>"},{"location":"channel_flow_transient/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Navier-Stokes equations for fluid flow and apply boundary conditions (e.g., no-slip walls, inlet velocity).</p> <pre><code>domain.bound_list[0].define_bc({'u': df.parabolic('y', 1,1,0.5),'v': 0})\ndomain.bound_list[1].define_bc({'u': 0,'v': 0})\ndomain.bound_list[2].define_bc({'p': 0})\ndomain.bound_list[3].define_bc({'u': 0,'v': 0})\ndomain.area_list[0].define_pde(df.NavierStokes(U=0.001, L=1, mu=0.001, rho=1000))\ndomain.area_list[1].define_ic({'u': 0,'v': 0})\n\nfor geom in domain:\n    geom.define_time([0, 10], 'random')\n\ndomain.show_setup()\n</code></pre> <pre><code>C:\\Users\\thamm\\OneDrive\\Documents\\1 - Projects\\0 - STEM\\2 - Numerical Physics\\9 - PINNs\\deepflow\\src\\deepflow\\physicsinformed.py:122: UserWarning: expo_scaling has not yet defined. False is set as default.\n  warnings.warn(\"expo_scaling has not yet defined. False is set as default.\")\n</code></pre> <p></p> <p>Sample initial points for training.</p> <pre><code>domain.sampling_lhs(bound_sampling_res=[1000, 1000, 1000, 1000], area_sampling_res=[2000, 2000])\ndomain.show_coordinates(display_physics=False)\n</code></pre> <p></p>"},{"location":"channel_flow_transient/#3-train-the-pinn-model","title":"3. Train the PINN model","text":"<p>Define how collocation points are sampled during training.</p> <pre><code>def do_in_adam(epoch, model):\n    return\n\ndef do_in_lbfgs(epoch, model):\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3(bound_sampling_res=[1000, 1000, 1000, 1000], area_sampling_res=[2000, 2000])\n        print(domain)\n</code></pre> <p>Train the model using Adam for initial training (faster convergence).</p> <pre><code>model0 = df.PINN(width=50, length=5, input_vars=['x','y','t'], output_vars=['u','v','p'])\n\n# Train the model\nmodel1, model1best = model0.train_adam(\n    learning_rate=0.001,\n    epochs=1000,\n    calc_loss=df.calc_loss_simple(domain),\n    threshold_loss=0.005,\n    do_between_epochs=do_in_adam)\n</code></pre> <pre><code>Epoch: 1, total_loss: 0.91400, bc_loss: 0.86594, pde_loss: 0.00009, ic_loss: 0.04798\nEpoch: 200, total_loss: 0.15948, bc_loss: 0.13487, pde_loss: 0.02015, ic_loss: 0.00446\nEpoch: 400, total_loss: 0.03458, bc_loss: 0.01444, pde_loss: 0.01070, ic_loss: 0.00945\nEpoch: 600, total_loss: 0.02541, bc_loss: 0.01232, pde_loss: 0.00730, ic_loss: 0.00580\nEpoch: 800, total_loss: 0.02111, bc_loss: 0.01105, pde_loss: 0.00541, ic_loss: 0.00465\nEpoch: 1000, total_loss: 0.01774, bc_loss: 0.00972, pde_loss: 0.00420, ic_loss: 0.00383\nEpoch: 1000, total_loss: 0.01774, bc_loss: 0.00972, pde_loss: 0.00420, ic_loss: 0.00383\n</code></pre> <p>Refine the model using LBFGS for higher precision.</p> <pre><code># Train the model\nmodel2 = model1best.train_lbfgs(\n    calc_loss=df.calc_loss_simple(domain),\n    epochs=350,\n    threshold_loss=0.0001,\n    do_between_epochs=do_in_lbfgs)\n</code></pre> <pre><code>Epoch: 970, total_loss: 0.01532, bc_loss: 0.00655, pde_loss: 0.00497, ic_loss: 0.00379\nEpoch: 1020, total_loss: 0.00327, bc_loss: 0.00056, pde_loss: 0.00224, ic_loss: 0.00047\nEpoch: 1070, total_loss: 0.00192, bc_loss: 0.00034, pde_loss: 0.00129, ic_loss: 0.00028\nnumber of bound : ['0: 1296', '1: 1404', '2: 1442', '3: 1286']\nnumber of area : ['0: 2529', '1: 2622']\nEpoch: 1120, total_loss: 0.00205, bc_loss: 0.00038, pde_loss: 0.00143, ic_loss: 0.00024\nEpoch: 1170, total_loss: 0.00119, bc_loss: 0.00020, pde_loss: 0.00084, ic_loss: 0.00015\nnumber of bound : ['0: 1605', '1: 1724', '2: 1870', '3: 1579']\nnumber of area : ['0: 3057', '1: 3367']\nEpoch: 1220, total_loss: 0.00146, bc_loss: 0.00027, pde_loss: 0.00109, ic_loss: 0.00010\nEpoch: 1270, total_loss: 0.00080, bc_loss: 0.00017, pde_loss: 0.00058, ic_loss: 0.00005\nnumber of bound : ['0: 1886', '1: 2110', '2: 2258', '3: 1964']\nnumber of area : ['0: 3618', '1: 4054']\nEpoch: 1319, total_loss: 0.00086, bc_loss: 0.00020, pde_loss: 0.00059, ic_loss: 0.00006\n</code></pre> <pre><code>domain.show_coordinates()\n</code></pre> <p></p> <p>Save or Load the model for later use</p> <pre><code>model2.save_as_pickle(\"model.pkl\")\nmodel2 = df.load_from_pickle(\"model.pkl\")\n</code></pre>"},{"location":"channel_flow_transient/#4-visualization","title":"4. Visualization","text":""},{"location":"channel_flow_transient/#41-visualize-area","title":"4.1 Visualize area","text":"<pre><code>df.Visualizer.refwidth_default = 6\n</code></pre> <pre><code># Create object for evaluation\narea_eval = domain.area_list[0].evaluate(model2)\n# Sampling uniform points\narea_eval.sampling_area([400, 80])\n# Show available data's key\narea_eval.define_time(10)\nprint(area_eval)\n</code></pre> <pre><code>Available data keys: ('u', 'v', 'p', 'pde_residual', 'x', 'y', 'u_x', 'u_y', 'v_x', 'v_y', 'p_x', 'p_y', 'continuity_residual', 'x_momentum_residual', 'y_momentum_residual', 't', 'total_loss', 'bc_loss', 'pde_loss', 'ic_loss')\n</code></pre> <pre><code>area_eval['v_mag'] = (area_eval['u']**2 + area_eval['v']**2)**0.5\n</code></pre> <pre><code>_ = area_eval.plot_color('v_mag', s=2, cmap='jet').savefig(\"colorplot_v_mag.png\")\n_ = area_eval.plot_color('u', s=2, cmap='rainbow')\n_ = area_eval.plot_color('v', s=2, cmap='rainbow')\n_ = area_eval.plot_color('p', s=2, cmap='rainbow')\n_ = area_eval.plot_streamline('u', 'v', cmap = 'jet')\n_ = area_eval.plot_color('pde_residual', s=2, cmap='viridis')\n</code></pre>"},{"location":"channel_flow_transient/#42-animate-area","title":"4.2 Animate Area","text":"<pre><code>anim = area_eval.plot_animate('u', range_t=[0.05, 8.1], dt = 0.1, frame_interval=100, cmap = 'rainbow', s=1, color_range=[0,1])\nanim.save(\"animation.gif\")\n</code></pre>"},{"location":"channel_flow_transient/#43-visualize-neural-network-data","title":"4.3 Visualize Neural Network data","text":"<pre><code>_ = area_eval.plot_loss_curve(log_scale=True)\n</code></pre>"},{"location":"channel_flow_transient/#44-export-data","title":"4.4 Export data","text":"<pre><code># store the x,y,velocity_magnitude data\nx_data = area_eval.data_dict['x']\ny_data = area_eval.data_dict['y']\nu_data = area_eval.data_dict['u']\n\n#save as txt file\nimport numpy as np\narray = np.column_stack((x_data, y_data, u_data))\nnp.savetxt('outlet_velocity.txt', array)\n</code></pre>"},{"location":"cylinder_flow_steady/","title":"Channel Flow (Steady) DEMO code","text":"<p>This notebook demonstrates solving steady-state Flow around cylinder with the same setup as this paper https://arxiv.org/abs/2002.10558</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n</code></pre> <pre><code>Deepflow is runned on: cuda\n</code></pre>"},{"location":"cylinder_flow_steady/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain: a rectangle with a circular obstacle (cylinder). This defines the area for simulation.</p> <pre><code>circle = df.geometry.circle(0.2, 0.2, 0.05)\nrectangle = df.geometry.rectangle([0,1.1], [0,0.41])\narea = rectangle - circle\n</code></pre> <pre><code>domain = df.domain(area, circle.bound_list)\ndomain.show_setup()\n</code></pre> <p></p>"},{"location":"cylinder_flow_steady/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Navier-Stokes equations for fluid flow and apply boundary conditions (e.g., no-slip walls, inlet velocity).</p> <pre><code>domain.bound_list[0].define_bc({'u': ['y', lambda x:  4*1*(0.41-x)*x/0.41**2], 'v': 0})\ndomain.bound_list[1].define_bc({'u': 0,'v': 0})\ndomain.bound_list[2].define_bc({'p': 0})\ndomain.bound_list[3].define_bc({'u': 0,'v': 0})\ndomain.bound_list[4].define_bc({'u': 0, 'v': 0})\ndomain.bound_list[5].define_bc({'u': 0, 'v': 0})\ndomain.area_list[0].define_pde(df.NavierStokes(U=1, L=1, mu=0.02, rho=1))\ndomain.show_setup()\n</code></pre> <p></p> <p>Sample initial points for training.</p> <pre><code>domain.sampling_lhs(bound_sampling_res=[1000, 1000, 1000, 1000, 1000, 1000], area_sampling_res=[4000])\ndomain.show_coordinates(display_physics=False)\n</code></pre> <p></p>"},{"location":"cylinder_flow_steady/#3-train-the-pinn-model","title":"3. Train the PINN model","text":"<p>Define how collocation points are sampled during training.</p> <pre><code>def do_in_adam(epoch, model):\n    return\n\ndef do_in_lbfgs(epoch, model):\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3(bound_sampling_res=[1000, 1000, 1000, 1000, 1000, 1000], area_sampling_res=[4000])\n        print(domain)\n</code></pre> <p>Train the model using Adam for initial training (faster convergence).</p> <pre><code>model0 = df.PINN(width=50, length=5, input_vars=['x','y'], output_vars=['u','v','p'])\n\n# Train the model\nmodel1, model1best = model0.train_adam(\n    learning_rate=0.004,\n    epochs=2000,\n    calc_loss=df.calc_loss_simple(domain),\n    threshold_loss=0.01,\n    do_between_epochs=do_in_adam)\n</code></pre> <pre><code>Epoch: 1, total_loss: 0.73840, bc_loss: 0.73788, pde_loss: 0.00053\nEpoch: 200, total_loss: 0.22851, bc_loss: 0.20319, pde_loss: 0.02532\nEpoch: 400, total_loss: 0.20562, bc_loss: 0.17889, pde_loss: 0.02673\nEpoch: 600, total_loss: 0.19221, bc_loss: 0.16597, pde_loss: 0.02624\nEpoch: 800, total_loss: 0.18192, bc_loss: 0.16069, pde_loss: 0.02123\nEpoch: 1000, total_loss: 0.17445, bc_loss: 0.14232, pde_loss: 0.03212\nEpoch: 1200, total_loss: 0.14289, bc_loss: 0.12102, pde_loss: 0.02187\nEpoch: 1400, total_loss: 0.24062, bc_loss: 0.21394, pde_loss: 0.02669\nEpoch: 1600, total_loss: 0.21580, bc_loss: 0.18649, pde_loss: 0.02930\nEpoch: 1800, total_loss: 0.20538, bc_loss: 0.17723, pde_loss: 0.02815\nEpoch: 2000, total_loss: 0.20238, bc_loss: 0.16498, pde_loss: 0.03740\n</code></pre> <p>Refine the model using LBFGS for higher precision.</p> <pre><code># Train the model\nmodel2 = model1best.train_lbfgs(\n    calc_loss=df.calc_loss_simple(domain),\n    epochs=450,\n    threshold_loss=0.0001,\n    do_between_epochs=do_in_lbfgs)\n</code></pre> <pre><code>Epoch: 1248, total_loss: 0.13073, bc_loss: 0.10979, pde_loss: 0.02094\nEpoch: 1298, total_loss: 0.02247, bc_loss: 0.01089, pde_loss: 0.01158\nEpoch: 1348, total_loss: 0.00434, bc_loss: 0.00100, pde_loss: 0.00334\nnumber of bound : ['0: 1437', '1: 1381', '2: 1398', '3: 1516', '4: 1517', '5: 1363']\nnumber of area : ['0: 5332']\nEpoch: 1398, total_loss: 0.00307, bc_loss: 0.00057, pde_loss: 0.00250\nEpoch: 1448, total_loss: 0.00160, bc_loss: 0.00033, pde_loss: 0.00127\nnumber of bound : ['0: 1807', '1: 1708', '2: 1987', '3: 1895', '4: 1936', '5: 1821']\nnumber of area : ['0: 6368']\nEpoch: 1498, total_loss: 0.00177, bc_loss: 0.00034, pde_loss: 0.00143\nEpoch: 1548, total_loss: 0.00118, bc_loss: 0.00026, pde_loss: 0.00093\nnumber of bound : ['0: 2158', '1: 1938', '2: 2504', '3: 2186', '4: 2344', '5: 2235']\nnumber of area : ['0: 7266']\nTraining interrupted by user.\n</code></pre> <pre><code>domain.show_coordinates()\n</code></pre> <p></p> <p>Save or Load the model for later use</p> <pre><code>model2.save_as_pickle(\"model.pkl\")\nmodel2 = df.load_from_pickle(\"model.pkl\")\n</code></pre>"},{"location":"cylinder_flow_steady/#4-visualization","title":"4. Visualization","text":""},{"location":"cylinder_flow_steady/#41-visualize-area","title":"4.1 Visualize area","text":"<pre><code># Create object for evaluation\narea_eval = domain.area_list[0].evaluate(model2)\n# Sampling uniform points\narea_eval.sampling_area([300, 150])\n# Show available data's key\nprint(area_eval)\n</code></pre> <pre><code>Available data keys: ('u', 'v', 'p', 'pde_residual', 'x', 'y', 'u_x', 'u_y', 'v_x', 'v_y', 'p_x', 'p_y', 'continuity_residual', 'x_momentum_residual', 'y_momentum_residual', 'total_loss', 'bc_loss', 'pde_loss')\n</code></pre> <pre><code>area_eval.plot_color('u', s=2, cmap='rainbow').savefig(\"colorplot_u.png\")\n_ = area_eval.plot_color('v', s=2, cmap='rainbow')\n_ = area_eval.plot_color('p', s=2, cmap='rainbow')\n_ = area_eval.plot_streamline('u', 'v', cmap = 'jet')\n_ = area_eval.plot('pde_residual')\n</code></pre> <pre><code>C:\\Users\\thamm\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\IPython\\core\\events.py:82: UltraPlotWarning: Tick label sharing not implemented for &lt;class 'ultraplot.axes.three.ThreeAxes'&gt; subplots.\n  func(*args, **kwargs)\n</code></pre> <pre><code>C:\\Users\\thamm\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\IPython\\core\\pylabtools.py:170: UltraPlotWarning: Tick label sharing not implemented for &lt;class 'ultraplot.axes.three.ThreeAxes'&gt; subplots.\n  fig.canvas.print_figure(bytes_io, **kw)\n</code></pre>"},{"location":"cylinder_flow_steady/#42-visualize-bound","title":"4.2 Visualize bound","text":"<pre><code># Create object for evaluation\nbound_visual = domain.bound_list[2].evaluate(model2)\nbound_visual.sampling_line(200) # Sampling uniform points\n</code></pre> <pre><code>_ = bound_visual.plot_color('u', cmap = 'rainbow')\n_ = bound_visual.plot(x_axis = 'y', y_axis='u')\n</code></pre> <pre><code>C:\\Users\\thamm\\OneDrive\\Documents\\1 - Projects\\0 - STEM\\2 - Numerical Physics\\9 - PINNs\\deepflow\\src\\deepflow\\visualization.py:40: UserWarning: Attempting to set identical low and high xlims makes transformation singular; automatically expanding.\n  ax.set_xlim(self.data_dict[x_axis].min(), self.data_dict[x_axis].max())\n</code></pre>"},{"location":"cylinder_flow_steady/#43-visualize-neural-network-data","title":"4.3 Visualize Neural Network data","text":"<pre><code>_ = bound_visual.plot_loss_curve(log_scale=True)\n</code></pre>"},{"location":"cylinder_flow_steady/#44-export-data","title":"4.4 Export data","text":"<pre><code># store the x,y,velocity_magnitude data\nx_data = bound_visual.data_dict['x']\ny_data = bound_visual.data_dict['y']\nu_data = bound_visual.data_dict['u']\n\n#save as txt file\nimport numpy as np\narray = np.column_stack((x_data, y_data, u_data))\nnp.savetxt('outlet_velocity.txt', array)\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>DeepFlow comes with several examples to help you get started.</p> <ul> <li>One-dimensional Burgers Equation</li> <li>Steady Channel Flow (Cavity)</li> <li>Steady Cylinder Flow</li> <li>Steady BFS Flow</li> <li>Transient Channel Flow</li> <li>2D Heat Equation</li> </ul> <p>You can find the source notebooks in the <code>examples/</code> directory of the repository.</p>"},{"location":"heat_eq/","title":"2D Unsteady Heat Equation DEMO code","text":"<p>This notebook demonstrates solving Unsteady 2D Fourier's Heat Equation using PINNs.</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n</code></pre> <pre><code>Deepflow is runned on: cuda\n</code></pre>"},{"location":"heat_eq/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain</p> <pre><code>rectangle = df.geometry.rectangle([0, 1], [0, 1])\nrectangle1 = df.geometry.rectangle([0, 1], [0, 1])\ndomain = df.domain(rectangle, rectangle1.area_list)\ndomain.show_setup()\n</code></pre> <p></p>"},{"location":"heat_eq/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Burgers eq (spatial version) apply boundary conditions.</p> <pre><code># Define Boundary Conditions\ndomain.bound_list[0].define_bc({'u': 0})   # Inflow: u=1\ndomain.bound_list[1].define_bc({'u': 0})   # Inflow: u=1\ndomain.bound_list[2].define_bc({'u': 0})   # Inflow: u=1\ndomain.bound_list[3].define_bc({'u': 1})  # Wall: No slip\n\n# Define PDE (Heat Equation) and Initial Condition\ndomain.area_list[0].define_pde(df.pde.HeatEquation(0.1))\ndomain.area_list[1].define_ic({'u': 0})\n\n# Define time domain\nfor g in domain:\n    g.define_time(range_t = [0, 1], sampling_scheme='random')\n\ndomain.show_setup()\n</code></pre> <pre><code>C:\\Users\\thamm\\OneDrive\\Documents\\1 - Projects\\0 - STEM\\2 - Numerical Physics\\9 - PINNs\\deepflow\\src\\deepflow\\physicsinformed.py:122: UserWarning: expo_scaling has not yet defined. False is set as default.\n  warnings.warn(\"expo_scaling has not yet defined. False is set as default.\")\n</code></pre> <p></p>"},{"location":"heat_eq/#2-generate-training-data","title":"2. Generate Training Data","text":"<p>Sample initial points for training. After sampling, Deepflow will automatically generate training datasets based on the defined physics.</p> <pre><code># Sample points: [Left, Bottom, Right, Top], [Interior]\ndomain.sampling_lhs([1000, 1000, 2000, 1000], [2000, 2000])\ndomain.show_coordinates(display_physics=True)\n</code></pre> <p></p>"},{"location":"heat_eq/#3-train-the-model","title":"3. Train the Model","text":"<p>Define the resampling scheme during training. R3 scheme is recommended.</p> <pre><code>def do_in_adam(epoch, model):\n    if epoch % 1000 == 0 and epoch &gt; 0:\n        domain.sampling_R3([1000, 1000, 2000, 1000], [2000, 2000])\n        print(domain)\n\ndef do_in_lbfgs(epoch, model):\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3([1000, 1000, 2000, 1000], [2000, 2000])\n        print(domain)\n</code></pre> <p>Train the model using Adam optimizer followed by L-BFGS optimizer.</p> <pre><code>model0 = df.PINN(width=32, length=4, input_vars=['x','y','t'], output_vars=['u'])\nmodel1, model1_best = model0.train_adam(\n    calc_loss = df.calc_loss_simple(domain),\n    learning_rate=0.004,\n    do_between_epochs=do_in_adam,\n    epochs=2000)\n</code></pre> <pre><code>Epoch: 1, total_loss: 1.07443, bc_loss: 1.07223, pde_loss: 0.00057, ic_loss: 0.00163\nEpoch: 200, total_loss: 0.14737, bc_loss: 0.10960, pde_loss: 0.00755, ic_loss: 0.03022\nEpoch: 400, total_loss: 0.12092, bc_loss: 0.09239, pde_loss: 0.00619, ic_loss: 0.02235\nEpoch: 600, total_loss: 0.10623, bc_loss: 0.08636, pde_loss: 0.00744, ic_loss: 0.01244\nEpoch: 800, total_loss: 0.06537, bc_loss: 0.04880, pde_loss: 0.00647, ic_loss: 0.01010\nEpoch: 1000, total_loss: 0.05430, bc_loss: 0.03624, pde_loss: 0.00955, ic_loss: 0.00850\nnumber of bound : ['0: 1321', '1: 1590', '2: 2388', '3: 1253']\nnumber of area : ['0: 2550', '1: 2429']\nEpoch: 1200, total_loss: 0.06119, bc_loss: 0.04864, pde_loss: 0.00576, ic_loss: 0.00679\nEpoch: 1400, total_loss: 0.09882, bc_loss: 0.07925, pde_loss: 0.00781, ic_loss: 0.01176\nEpoch: 1600, total_loss: 0.05544, bc_loss: 0.04448, pde_loss: 0.00462, ic_loss: 0.00634\nEpoch: 1800, total_loss: 0.05426, bc_loss: 0.03893, pde_loss: 0.00863, ic_loss: 0.00671\nEpoch: 2000, total_loss: 0.04004, bc_loss: 0.03020, pde_loss: 0.00445, ic_loss: 0.00539\nnumber of bound : ['0: 1493', '1: 1954', '2: 2733', '3: 1410']\nnumber of area : ['0: 3008', '1: 2623']\n</code></pre> <pre><code>model2 = model1_best.train_lbfgs(calc_loss = df.calc_loss_simple(domain), epochs=450, do_between_epochs=do_in_lbfgs, threshold_loss=5e-3)\n</code></pre> <pre><code>Epoch: 2000, total_loss: 0.05703, bc_loss: 0.04316, pde_loss: 0.00694, ic_loss: 0.00693\nEpoch: 2050, total_loss: 0.01069, bc_loss: 0.00796, pde_loss: 0.00205, ic_loss: 0.00068\nTraining interrupted by user.\n</code></pre> <pre><code>domain.show_coordinates(display_physics=False)\n</code></pre> <p></p>"},{"location":"heat_eq/#4-visualization","title":"4. Visualization","text":"<pre><code># Evaluate the best model\nprediction = domain.area_list[0].evaluate(model2)\nprediction.sampling_area([200, 200])\nprediction.define_time(0.5)\n</code></pre>"},{"location":"heat_eq/#41-visualize-pde-area","title":"4.1 Visualize PDE area","text":"<pre><code># Plot Temperature Field\n_ = prediction.plot('u', color='plasma')\n_.savefig('heat_eq_u.png', dpi=200)\n\n# Plot Training Loss\n_ =prediction.plot_loss_curve(log_scale=True, keys=['total_loss'])\n</code></pre> <pre><code>C:\\Users\\thamm\\AppData\\Local\\Temp\\ipykernel_15656\\1618917411.py:3: UltraPlotWarning: Tick label sharing not implemented for &lt;class 'ultraplot.axes.three.ThreeAxes'&gt; subplots.\n  _.savefig('heat_eq_u.png', dpi=200)\nC:\\Users\\thamm\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\IPython\\core\\events.py:82: UltraPlotWarning: Tick label sharing not implemented for &lt;class 'ultraplot.axes.three.ThreeAxes'&gt; subplots.\n  func(*args, **kwargs)\nC:\\Users\\thamm\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python311\\site-packages\\IPython\\core\\pylabtools.py:170: UltraPlotWarning: Tick label sharing not implemented for &lt;class 'ultraplot.axes.three.ThreeAxes'&gt; subplots.\n  fig.canvas.print_figure(bytes_io, **kw)\n</code></pre>"},{"location":"heat_eq/#42-animate-the-solution-over-time","title":"4.2 Animate the solution over time","text":"<pre><code>prediction.sampling_area([160, 160])\nprediction.plot_animate('u', range_t = [0.02, 1.02], dt = 0.02, frame_interval=100, cmap='plasma', plot_type='scatter', s=1.7).save('heat_equation.mp4', dpi = 200)\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This example demonstrates how to simulate Steady channel flow under 20 lines of code! We recommend using a Python notebook (<code>.ipynb</code>) for interactive experience.</p>"},{"location":"quickstart/#1-define-the-geometry-and-physics","title":"1. Define the Geometry and Physics","text":"<p><pre><code>import deepflow as df\n\n# Define the area and bounds\nrectangle = df.geometry.rectangle([0, 5], [0, 1])\ndomain = df.domain(rectangle)\n\ndomain.show_setup() # Display the domain setup\n</code></pre> <pre><code># Define Boundary Conditions\ndomain.bound_list[0].define_bc({'u': 1, 'v': 0})  # Inflow: u=1\ndomain.bound_list[1].define_bc({'u': 0, 'v': 0})  # Wall: No slip\ndomain.bound_list[2].define_bc({'p': 0})          # Outflow: p=0\ndomain.bound_list[3].define_bc({'u': 0, 'v': 0})  # Wall: No slip\n\n# Define PDE (Navier-Stokes)\ndomain.area_list[0].define_pde(df.pde.NavierStokes(U=0.0001, L=1, mu=0.001, rho=1000))\n\ndomain.show_setup() # Display the domain setup\n</code></pre> </p> <p><pre><code># Sample points: [Left, Bottom, Right, Top], [Interior]\ndomain.sampling_random([200, 400, 200, 400], [5000])\ndomain.show_coordinates(display_physics=True)\n</code></pre> </p>"},{"location":"quickstart/#2-create-and-train-the-model","title":"2. Create and Train the model","text":"<p><pre><code># Initialize the PINN model\nmodel0 = df.PINN(width=40, length=4)\n</code></pre> <pre><code># Train the model using Adam Optimizer\nmodel1 = model0.train_adam(\n    calc_loss=df.calc_loss_simple(domain),\n    learning_rate=0.001,\n    epochs=2000,)\n</code></pre></p>"},{"location":"quickstart/#3-visualize-results","title":"3. Visualize Results","text":"<p><pre><code># Evaluate the best model\nprediction = domain.area_list[0].evaluate(model1_best)\nprediction.sampling_area([500, 100])\n\n# Plot Velocity Field\n_ = prediction.plot_color('u', cmap='jet')\n\n# Plot Training Loss\n_ =prediction.plot_loss_curve()\n</code></pre> </p>"},{"location":"reference/","title":"API Reference","text":"<p>This page lists the main classes and functions available in <code>deepflow</code>.</p>"},{"location":"reference/#domain","title":"Domain","text":"<p>The domain module handles the creation and management of the computational domain, including geometry, boundary conditions, and sampling.</p>"},{"location":"reference/#domain_1","title":"<code>domain</code>","text":"<pre><code>def domain(*geometries) -&gt; ProblemDomain\n</code></pre> <p>Creates a <code>ProblemDomain</code> instance from a list of <code>Area</code> or <code>Bound</code> objects.</p> <p>Arguments: - <code>*geometries</code>: Can be single <code>Area</code>/<code>Bound</code> objects or lists of them.</p>"},{"location":"reference/#problemdomain","title":"<code>ProblemDomain</code>","text":"<p><pre><code>class ProblemDomain(bound_list, area_list):\n</code></pre> The main class managing the physics problem.</p> <p>Methods: - <code>sampling_uniform(bound_sampling_res, area_sampling_res)</code>: Samples points uniformly. - <code>sampling_random(bound_sampling_res, area_sampling_res)</code>: Samples points randomly. - <code>sampling_lhs(bound_sampling_res, area_sampling_res)</code>: Samples points using Latin Hypercube Sampling. - <code>sampling_R3(bound_sampling_res, area_sampling_res)</code>: Samples points using R3 refinement. - <code>show_setup()</code>: Plots the domain geometry and boundary conditions. - <code>show_coordinates(display_physics=False)</code>: Plots the sampled collocation points.</p>"},{"location":"reference/#calc_loss_simple","title":"<code>calc_loss_simple</code>","text":"<p><pre><code>def calc_loss_simple(domain: ProblemDomain) -&gt; callable\n</code></pre> Returns a loss function that calculates the weighted sum of boundary and PDE losses for the given domain.</p>"},{"location":"reference/#geometry","title":"Geometry","text":"<p>The <code>deepflow.geometry</code> module provides helper functions to create 1D and 2D geometries.</p>"},{"location":"reference/#rectangle","title":"<code>rectangle</code>","text":"<p><pre><code>def rectangle(range_x: List[float], range_y: List[float]) -&gt; Area\n</code></pre> Creates a rectangular area.</p>"},{"location":"reference/#circle","title":"<code>circle</code>","text":"<p><pre><code>def circle(x: float, y: float, r: float) -&gt; Area\n</code></pre> Creates a circular area.</p>"},{"location":"reference/#bound","title":"<code>Bound</code>","text":"<p>Represents a boundary (e.g., line segment).</p>"},{"location":"reference/#area","title":"<code>Area</code>","text":"<p>Represents a 2D area. Supports subtraction (e.g., <code>rect - circle</code>).</p>"},{"location":"reference/#pde","title":"PDE","text":"<p>The <code>deepflow.pde</code> module contains standard Partial Differential Equations.</p>"},{"location":"reference/#navierstokes","title":"<code>NavierStokes</code>","text":"<p><pre><code>class NavierStokes(U, L, mu, rho)\n</code></pre> 2D Incompressible Navier-Stokes equations.</p>"},{"location":"reference/#burgersequation1d","title":"<code>BurgersEquation1D</code>","text":"<p><pre><code>class BurgersEquation1D(nu)\n</code></pre> 1D Burgers' equation.</p>"},{"location":"reference/#heatequation","title":"<code>HeatEquation</code>","text":"<p><pre><code>class HeatEquation(alpha)\n</code></pre> 2D Heat equation.</p>"},{"location":"reference/#neural-network","title":"Neural Network","text":""},{"location":"reference/#pinn","title":"<code>PINN</code>","text":"<p><pre><code>class PINN(width, length, input_vars, output_vars, activation=nn.Tanh())\n</code></pre> Physics-Informed Neural Network model.</p> <p>Methods: - <code>train_adam(calc_loss, learning_rate, epochs, ...)</code>: Train using Adam optimizer. - <code>train_lbfgs(calc_loss, epochs, ...)</code>: Train using L-BFGS optimizer. - <code>save_as_pickle(path)</code>: Save model. - <code>load_from_pickle(path)</code>: Load model.</p>"},{"location":"reference/#evaluation","title":"Evaluation","text":""},{"location":"reference/#evaluator-visualizer","title":"<code>Evaluator</code> (Visualizer)","text":"<p>Returned by <code>domain.area_list[i].evaluate(model)</code>.</p> <p>Methods: - <code>sampling_area(res_list)</code>: Sample points for visualization. - <code>plot(key)</code>: Plot a variable. - <code>plot_color(key)</code>: Plot a variable as a color map. - <code>plot_streamline(u, v)</code>: Plot streamlines. - <code>plot_loss_curve()</code>: Plot loss history. - <code>plot_animate(...)</code>: Create animation (for transient problems).</p>"}]}